教材第72页算法设计题目12
称正读和反读都相同的字符序列为“回文”，例如，“abcddcba”“qwerewq”是回文，“ashgash”不是回文。试写一个算法判断读入的一个以‘@’为结束符的字符序列是否为回文。
void hw(char *s)
{
    char stack[100];
    int top = -1;
    int i = 0;
    
    // 入栈
    while (s[i] != '@')
    {
        stack[++top] = s[i];
        i++;
    }
    
    // 出栈并比较
    i = 0;
    while (top >= 0)
    {
        if (s[i] != stack[top--])
        {
            printf("Not a palindrome\n");
            return;
        }
        i++;
    }
    
    printf("Is a palindrome\n");
}
教材第72页算法设计题目17
写算法，借助于栈将一个单链表置逆。
void reverse(int *data, int m)
{
    int stack[100];
    int top = -1;
    int i;
    
    // 入栈
    for (i = 0; i < m; i++)
    {
        stack[++top] = data[i];
    }
    
    // 出栈
    for (i = 0; i < m; i++)
    {
        data[i] = stack[top--];
    }
}
教材第72页算法设计题目18
两个栈共享向量空间data[m]，它们的栈底分别设在向量的两端，每个元素占一个: push(s, i, x), pop(s, i) top(s, i), s i=0和1，用以指示栈号。
// 入栈操作
// i: 栈号(0或1)
// x: 要入栈的元素
// 返回值: 1表示成功，0表示失败(栈满)
int push(DblStack *s, int i, int x)
{
    if (i < 0 || i > 1) {
        printf("栈号错误\n");
        return 0;
    }
    // 检查栈是否满
    if (s->top[0] + 1 == s->top[1]) {
        printf("栈满\n");
        return 0;
    }
    
    if (i == 0) {
        s->data[++s->top[0]] = x;  // 栈1从前往后增长
    } else {
        s->data[--s->top[1]] = x;  // 栈2从后往前增长
    }
    return 1;
}
// 出栈操作
// i: 栈号(0或1)
// 返回值: 出栈的元素，如果栈空则返回-1
int pop(DblStack *s, int i) {
    if (i < 0 || i > 1) {
        printf("栈号错误\n");
        return -1;
    }
    
    if (i == 0) {
        if (s->top[0] == -1) {
            printf("栈0空\n");
            return -1;
        }
        return s->data[s->top[0]--];
    } else {
        if (s->top[1] == MAXSIZE) {
            printf("栈1空\n");
            return -1;
        }
        return s->data[s->top[1]++];
    }
}
// 取栈顶元素
// i: 栈号(0或1)
// 返回值: 栈顶元素，如果栈空则返回-1
int top(DblStack *s, int i) {
    if (i < 0 || i > 1) {
        printf("栈号错误\n");
        return -1;
    }
    
    if (i == 0) {
        if (s->top[0] == -1) {
            printf("栈0空\n");
            return -1;
        }
        return s->data[s->top[0]];
    } else {
        if (s->top[1] == MAXSIZE) {
            printf("栈1空\n");
            return -1;
        }
        return s->data[s->top[1]];
    }
}
